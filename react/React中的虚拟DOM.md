#### 一、当state或props中的数据发生变化需要重新渲染页面时
1. 没有虚拟DOM时，替换DOM树
> 1. state数据
> 2. jsx模板
> 3. 数据与模板结合生成DOM树，显示在页面上
> 4. 数据发生变化
> 5. 数据与模板结合生成新的DOM树，替换原始的DOM树

生成DOM树和替换DOM树很消耗性能。

2. 没有虚拟DOM时，比较DOM树
> 1. state数据
> 2. jsx模板
> 3. 数据与模板结合生成DOM树，显示在页面上
> 4. 数据发生变化
> 5. 数据与模板结合生成新的DOM树
> 6. 新的DOM树与原始的DOM树进行比较，发现差异
> 7. 操作DOM进行修改

操作DOM进行修改比替换DOM节约性能，但还是要生成新的DOM树，依旧很消耗性能。

3. 有虚拟DOM时，比较虚拟DOM（ 虚拟DOM就是一个js对象 ）
> 1. state数据
> 2. jsx模板
> 3. 数据与模板结合生成虚拟DOM
> 4. 根据虚拟DOM生成DOM树，显示在页面上
> 5. 数据发生变化
> 6. 数据与模板结合生成新的虚拟DOM
> 7. 新的虚拟DOM与原始的虚拟DOM进行比较，发现差异
> 8. 操作DOM进行修改

没有生成DOM树，而是创建了一个js对象（虚拟DOM），创建js对象消耗的性能非常小

#### 二、Diff算法
虚拟DOM的比较使用的是Diff算法
Diff算法使用的是同级比较，从第一级逐级向下比较，有差异的话，会停止比较直接修改，不会再向下比较，这样虽然在操作dom修改时比较消耗性能，但是它提升了比较速度。
![](https://upload-images.jianshu.io/upload_images/19863207-6044ae3fe30adc28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 三、React在做列表循环时，需要给每一项添加key值
没有key值，则在虚拟DOM比较时不好找差异，但是如果每一项都拥有一个不同的key值，则可以通过key值来判断有没有差异，所以有key对性能的提升有很大帮助。
key值应该尽量不要使用数组的索引(index)，因为其不稳定，比如：
遍历数组`["a", "b", "c"]`，则a、b、c的key值分别是0、1、2，但是当删除a后，b、c的key值变成了0、1。
